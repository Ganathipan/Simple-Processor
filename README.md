# CO224 Lab 5 - Task 5 Project Structure and Usage Guide

## Overview
This project implements a modular processor in Verilog HDL for CO224 Lab 5, Task 5. The design is structured to separate hardware-level modules, processor components, and instruction memory, supporting both unit and system-level testing. The organization is intended to facilitate learning, debugging, extensibility, and clear demonstration of digital design principles.

## Directory and File Structure (Detailed)

- **GateLevelModules/**
  - **Purpose:** Contains low-level (gate-level) Verilog code for fundamental arithmetic and logic units, specifically the shifter and multiplier.
  - **Contents:**
    - `shifter.v`, `multiplier.v`: Gate-level implementations of the shifter and multiplier modules, using only basic logic gates and flip-flops.
    - `shifter_tb.v`, `multiplier_tb.v`: Testbenches for verifying the correctness of each hardware module in isolation, with example input vectors and expected outputs.
  - **Why:** Verifying these modules independently ensures that the most basic building blocks of the processor are functionally correct before they are integrated into higher-level modules. This approach helps catch low-level bugs early and demonstrates the construction of complex operations from simple gates.

- **Modules/**
  - **Purpose:** Contains Verilog code for each single module of the processor, such as the ALU, control unit, program counter (PC), register file, and the CPU datapath.
  - **Contents:**
    - `alu.v`, `alu_tb.v`: Implements the Arithmetic Logic Unit, which performs arithmetic and logical operations. The testbench (`alu_tb.v`) provides test cases for each operation.
    - `control_unit.v`: Decodes instructions and generates control signals for the datapath.
    - `pc.v`: Implements the program counter, which tracks the current instruction address.
    - `cpu.v`: Top-level datapath module, instantiating and connecting all submodules.
    - Other files for additional modules (e.g., register file, multiplexers, etc.), each with clear comments explaining their logic and role.
    - Each module is accompanied by a testbench (e.g., `alu_tb.v`) for unit testing.
  - **Why:** Modular coding allows for easier debugging, reusability, and stepwise verification. Each module can be simulated and validated independently before system integration, making it easier to isolate and fix issues.
  - **How:** Modules are designed with clear interfaces (inputs/outputs) and are instantiated in higher-level modules (e.g., the CPU datapath). Comments in each file explain the function and logic of every block and signal.

- **InstructionMemory/**
  - **Purpose:** Stores all instruction-related files, including assembly source code and corresponding machine code.
  - **Contents:**
    - `.s` files: Assembly programs written for the processor, using the supported instruction set.
    - `.machine` files: Machine code generated by the assembler, ready to be loaded into instruction memory for simulation.
  - **Why:** Separating instruction memory files allows for easy modification and testing of different programs without altering hardware code. This supports rapid prototyping and debugging of both hardware and software.
  - **How:** The assembler converts `.s` files to `.machine` files, which are then used in processor simulations. The processor testbench loads the `.machine` file as its instruction memory.

- **FinalFunctioningUnits/**
  - **Purpose:** Contains the top-level processor integration files and waveform (testbench) files for final system-level testing and demonstration.
  - **Contents:**
    - `processor.v`: The complete processor, integrating all modules and connecting them to instruction and data memory.
    - `processor_tb.v`: Testbench for the full processor, which loads a machine code program, runs the processor, and generates a waveform file for analysis.
    - Waveform files (e.g., `.vcd` files) for use with tools like GTKWave, allowing you to visually inspect signal transitions and debug the processor's behavior.
  - **Why:** This directory is for verifying the entire processor in operation, running real programs, and observing results. It demonstrates the integration of all components and the processor's ability to execute complete instruction sequences.
  - **How:** The testbench loads machine code, runs the processor, and generates waveforms for analysis. Comments in the testbench explain how to interpret the results.

- **task5/**
  - **Purpose:** Contains the assembler source code, sample assembly programs, and scripts for generating memory images. This is the main entry point for software development and testing.
  - **Contents:**
    - `CO224Assembler_Modified.c`: The assembler that translates assembly code to machine code, supporting the custom instruction set. The code is commented to explain parsing, encoding, and error handling.
    - `sample_program.s`, `sample_bne_program.s`: Example assembly programs demonstrating different instructions and control flow.
    - `generate_memory_image.sh`: Script to automate the assembly and memory image generation process, making it easy to update instruction memory for simulation.
    - `README.md`: This documentation file, providing guidance for users and developers.
  - **Why:** Keeping assembler and scripts here centralizes the workflow for program development and testing, making it easy to assemble, simulate, and debug programs.

## Workflow: How to Compile, Simulate, and Test

### 1. Navigate to the Project Directory
```sh
cd ~/CO224_CA/VerilogHDL/lab5/task5
```

### 2. Compile the Assembler
```sh
gcc CO224Assembler_Modified.c -o CO224Assembler
```
- This creates an executable `CO224Assembler` for converting assembly to machine code.

### 3. Assemble an Assembly Program
```sh
./CO224Assembler sample_program.s
```
- This generates `sample_program.s.machine` in the same directory.
- You can write your own `.s` files and assemble them similarly.

### 4. Compile and Simulate Verilog Modules
- **Hardware-level modules (shifter, multiplier):**
```sh
cd ../GateLevelModules
iverilog -o shifter_tb shifter.v shifter_tb.v
vvp shifter_tb
iverilog -o multiplier_tb multiplier.v multiplier_tb.v
vvp multiplier_tb
```
- **Processor modules (ALU, control unit, etc.):**
```sh
cd ../Modules
iverilog -o alu_tb alu.v alu_tb.v
vvp alu_tb
# Repeat for other modules as needed
```
- **Final processor and waveform viewing:**
```sh
cd ../FinalFunctioningUnits
iverilog -o processor_tb processor.v processor_tb.v
vvp processor_tb
# Use gtkwave to view the waveform if needed
```

### 5. Instruction Memory
- Store your assembly and machine code files in the `InstructionMemory` directory for use in simulations.
- The processor testbench will load the `.machine` file as its instruction memory.

## Design Philosophy and Notes
- **Modularity:** Each hardware and processor component is coded and tested separately for clarity, reliability, and ease of debugging. This modular approach allows you to isolate and fix issues quickly.
- **Testbenches:** Every module has a dedicated testbench to verify its logic before system integration. Testbenches provide example inputs and check outputs, ensuring correctness at every stage.
- **Assembler:** Ignores comments and blank lines, and supports the instruction set defined in the processor. The assembler is robust to formatting and provides error messages for incorrect instructions.
- **Hardware Modules:** Shifter and multiplier are implemented at the gate level and tested independently before being used in the CPU. This demonstrates how complex operations are built from simple gates.
- **Instruction Set:** Assembly and machine code files are kept separate from hardware code for flexibility in program development. You can easily swap out programs without changing the hardware.
- **Integration:** The final processor is tested with real programs and waveforms are analyzed for functional verification. The integration testbench demonstrates the processor's ability to fetch, decode, and execute instructions correctly.
- **Documentation:** Each file and module is commented to explain its logic, purpose, and how it fits into the overall design. This README provides a roadmap for navigating and understanding the project.

## Example: Step-by-Step Workflow
1. **Write or edit an assembly program** in `task5/` or `InstructionMemory/` (e.g., `sample_program.s`).
2. **Assemble the program:**
   ```sh
   cd ~/CO224_CA/VerilogHDL/lab5/task5
   gcc CO224Assembler_Modified.c -o CO224Assembler
   ./CO224Assembler sample_program.s
   ```
3. **Copy the `.machine` file** to `InstructionMemory/` if needed.
4. **Simulate hardware modules** (e.g., shifter, multiplier) in `GateLevelModules/`:
   ```sh
   cd ../GateLevelModules
   iverilog -o shifter_tb shifter.v shifter_tb.v
   vvp shifter_tb
   ```
5. **Simulate processor modules** in `Modules/`:
   ```sh
   cd ../Modules
   iverilog -o alu_tb alu.v alu_tb.v
   vvp alu_tb
   ```
6. **Run the full processor simulation** in `FinalFunctioningUnits/`:
   ```sh
   cd ../FinalFunctioningUnits
   iverilog -o processor_tb processor.v processor_tb.v
   vvp processor_tb
   gtkwave processor_tb.vcd &
   ```

---
For any issues, check the comments in each file or refer to this README for guidance. Each module and testbench is commented to explain its logic and purpose. If you are new to Verilog or digital design, start by simulating the hardware modules, then move to processor modules, and finally run the full system.
